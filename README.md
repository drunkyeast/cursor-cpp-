# 10月20日
开始准备C++八股. 以后都用这个项目吧, 把一些知识点和相关代码都写在这里.
感觉侧重点很重要啊, 就怕那种方向错误, 白复习了.

## 杂记知识,想到什么写什么
fork的返回值问题, 子进程中返回0, 父进程中返回子进程的pid,这样父进程可以管理子进程, 反之不能.

## 程序的执行过程
脑海中要有那张图, 分类有很多很乱, 所以干脆分成(从下到上0x400000或0x804800或现代Linux用随机化地址, 抓大放小啊):
- .text 代码
- .rodata "hello word"等真正的常量, 以及const int的全局变量.
- .data 初始化的 非const的全局变量以及静态变量.
- .bss 未初始化的 非const的全局变量以及静态变量.
- 堆区/共享内存/栈区/内核虚拟内存

## ⭐怎么理解虚函数/怎么理解多态/静态多态与动态多态/重载与重写
### 1. 虚函数基本介绍
多态(Polymorphism)是C++面向对象OOP的三大特性之一, 虚函数virtual是实现多态的C++语法特性, 再往底层是动态绑定和虚函数表,是编译器的实现细节.

多态就是:父类指针指向子类对象, 通过虚函数(/动态绑定/虚函数表等概念), 运行时调用子类的函数/子类的实现, 实现"一个接口，多种实现". 例如设计一个函数,这个函数的参数是基类指针,但是可以通过这个基类指针调用子类对象. 比如射击游戏, 所有的枪都继承一个枪的基类, 人类需要有一个开枪的函数, 使用多态的话人类就只需要有一个开枪的函数就可以实现所有枪打出不同子弹. (如果不用多态, 那么人类就不只一个开枪函数了,就要对每把枪都要写一个开枪函数,因为开枪函数的参数是不同的枪的指针. 或者用别的枚举方法.)
父类指针指向子类对象, 自然而然, 从内存角度看, 子类对象的内存中前面就是父类的成员. 类型完全匹配.

```
Base* ptr = new Derived(); // 当父类指针指向子类对象; 会有两种判断情况,函数是否重写/覆盖,函数是否是虚函数. 
if (子类没有重写父类的某个函数) {
    if (该函数是虚函数) 父类指针ptr->调用父类的函数; // 语法正确只是没有多态效果而已, 也很常见.
    else (该函数不是虚函数) 父类指针ptr->调用父类的函数;
}
else if (子类重写了父类的某个函数) {
    if (该函数数虚函数) 父类指针ptr->调用子类的成员函数; // 所以重写且是虚函数才有多态效果!!!.
    else if (该函数不是虚函数) 父类指针ptr->调用父类的成员函数; // 这样就有问题, 1.多态失效-无法根据指向的实际对象调用对应函数 2.子类重写的逻辑被忽略
}
```

### 2. override关键字
子类父类的虚函数名称必须完全相同, 为了防止开发人员拼写错误, C++11添加了关键字override, void func () override; (注意:如果声明与分开写的话, override只能写在声明中, 定义中如果写override的话就编译报错, 因为它不属于函数签名的概念. 引申出函数签名).这个叫做重写（或覆盖）,可以理解成你骑上马, 是把之前的东西给覆盖了, 而overload是重载, 函数同名但不同参数, 可以想象成一个函数"卡车", 它装载了load了很多个函数, 同名不同参.
关于重载与重写，overload与override的区别，还有一个类似的并行与并发 Parallelism与Concurrency. 从英文的角度就很好区分了, para词根就是平行线嘛, 真正的同时运行.

### 3. 一个内存泄漏问题
父类的析构函数必须为虚函数：这一点很重要，当父类对象指向子类对象时，容易使独属于子类的内存泄露。会造成内存泄露的严重问题。
父类的析构函数必须为虚函数:这一点很重要, 父类指针指向子类对象时, 如果父类指针没有写成虚函数, 那么delete时, 执行父类的析构函数, 但应该调用子类的析构函数delete子类对象。这个问题就是前面代码块最后一点说的，存在问题：这就多态失效了-无法根据实际对象调用对应的析构函数, 子类的析构函数逻辑被忽略. 这样内存中,父类的对象空间被析构了,子类额外的独有的空间没有析构,造成内存泄漏.

### 4. 虚函数实现多态的底层原理
- 静态绑定:程序在编译时就确定了函数的地址,非虚函数在编译时就是静态绑定.
- 动态绑定:程序在编译时确定的事程序寻找函数地址的方法(比如用vptr去vtable中找),只有在程序运行时才可以确定程序的地址, 比如虚函数就是动态绑定.
- 虚函数是如何实现动态绑定的呢?答:每个带有虚函数的类(或者用术语:多态类)都会有一个虚函数表vtable放在程序的.rodata字段中,每个虚函数的类的对象(或者术语:多态类对象/多态对象)的前面都会有一个指向虚函数表的指针(紧挨着内存). 父类指针指向子类对象时,这个父类指针调用某个虚函数时,如何判断调用父类的虚函数,还是子类重写的虚函数呢?**在虚函数列表vtable中,子类是继承父类的虚函数表中的虚函数指针,但会对重写的函数进行覆盖**. 非虚函数的函数指针在虚函数表中吗？答:不在. 虚函数表中除了虚函数指针外,还有一些RTTI相关内容, 略.



## ⭐进程通信的方式有哪些? 他们的优缺点,主要应用场景有哪些? 虚拟地址怎么理解
总结: 需要跨主机就用socket; 需要持久化或文件操作加速用内存映射; 数据量大用共享内存+信号量; 简单父子进程用管道;
进程间通信(IPC,Inter-Process Communication)有
- **管道(匿名管道pipe)**:  
    - 优点: 简单易用; 内核自动同步，无需额外的同步机制(这个应该就是阻塞吧,管道为空read()时会阻塞); 适合简单地数据流传递; 
    - 缺点: 只能单向通信(双向通信要建立两个管道); 只能用于父子进程,亲缘关系进程(命名管道mkfifo可以解决这个问题); 容量有限,数据读取后就消失.
    - 应用场景: 命令行重定向,父子进程简单数据传输.
- **消息队列**: 消息队列是存放在内核中的消息链表，每个消息有类型标识，可以按类型接收。msgget(创建)/msgctl(控制/删除). 消息队列不删除会占用系统资源.
    - 优点: 相比于管道支持结构化信息,而管道是传递无结构的字节流;可以按类型接受;异步通信;内核自动同步;
    - 缺点: 容量有限,适合任务分发;独立于进程存在,需要手动删除(否则占用资源);只能本机通信;
    - 应用场景: 任务队列(生产者-消费者模型);
    - 补充1: 关于一些术语的理解: 比特流/二进制流(物理层);**字节流(以字节为单位,可以是文本流也可以是图片等非文本流)**;文本流("hello world"这样的); 所以管道传递"hello word"既可以叫做文本流, 也可以叫做字节流(更常用). 叫做二进制流技术上对但很不推荐. 总结:文本常用文本流或字节流形容. 图片音乐常用二进制流或字节流形容. 字节流比较通用, 答涉及到计网的物理层又用二进制流/比特流. 这些细节我不搞明白很不爽啊, 搞明白又觉得是在浪费时间.
    - 补充2: 关于zmq: zmq的mq虽然叫做消息队列,但不是传统的消息队列. zmq是高性能的异步消息传递库. 而消息队列属于内核相关,仅限于本机. kafka比zmq更复杂,这些也叫做消息队列但与进程间通信IPC的消息队列不是一个概念.
    - 补充3: 关于system five IPC: 很久以前Unix(1983年)定义的一套IPC机制(消息队列/共享内存/信号量这三种). 而管道是更早的Unix(1969年)定义的.
- **共享内存(shared memory)**: 最快的IPC,因为没有0拷贝,多个进程直接访问同一块物理内存,而其他IPC要拷贝两次以上,用户->内核->用户,socket还要通过网络. 常用函数shmget/shmctl创建于删除,shmat/shmdt(at表示attach,dt表示detach). 
    - 优点: 快,因为零拷贝且直接访问内存;可以共享大块数据;灵活
    - 缺点: 需要配合信号量或mutex锁进行同步操作防止冲突,比较复杂;

- **信号量(semaphore,信号灯或者古代的旗语)**: 不传递数据的，只是用于同步。P/V原子操作, P操作--, V操作++;
    - 应用场景: 搭配共享内存的同步控制;
- **信号(signal)**: 异步通知机制，类似"软件中断"。
    - 优点: 简单快速; 异步处理;
    - 缺点: 信息量极少; 可能丢失; 不能调用非异步安全函数.
    - 应用场景: 进程管理kill -9, ctrl + c等; 简单事件通知; 超时处理;
    - 补充: signal是系统级的, event不能跨进程不是IPC. python中可以用threading.Event用于线程间简单地同步. libevent的evnet是高性能网络服务器或I/O密集型应用.
- **套接字(socket)**: 
    - 优点: 唯一的跨主机通信; 双向通信; 支持多种协议栈;
    - 缺点: 性能低; 处理复杂, 要处理连接和断开; 用到协议栈有额外开销;
    - 应用场景: 这个需要说吗? 各种网络相关的; 本地守护进程通信(systemd/docker); 补充一下zmq/kafka.
- **内存映射** : 适用于文件操作加速.
    - 优点: 高效的文件操作(零拷贝); 按需加载; 自动持久化(而共享内存是临时的); 多进程共享文件
    - 缺点: 文件大小限制; 需手动同步; 管理复杂; (感觉跟共享内存差不多啊)
    - 应用场景: 大文件随机访问; 文件系统;
    - 补充1: mmap是memory map, **内存映射**. 它本身与内存共享还没有关系. **但他们再底层都是调用do_mmap();**; 很久一起我做个一个mmap的小项目, TFS, 什么淘宝分布式文件系统, 十多年前的老东西了; 依稀还记得大概是把一些小文件通过内存映射合并成一个大文件, 加速读取和存储. 大概就是每个小文件会**消耗很多的inode等元数据**, ls的目录项很多, 磁盘碎片化严重等等. 大概**做了一个索引块去代替inode等元数据,将inode等元数据从磁盘移动到内存中**, 把文件的主要内容也合并, 通过索引块的偏移量信息去找. 具体忘了,两年前写的吧.
### 虚拟地址怎么理解?
虚拟地址的本质：虚拟地址是操作系统给每个进程提供的一个"假象"，让每个进程都认为自己独占了整个内存空间。程序中所有的指针、变量地址，看到的都是虚拟地址，而不是真实的物理内存地址。
早期的计算机是直接用的物理地址的. 但虚拟地址可以方便内存管理. 其实还有一些关键词MMU/TLB/缺页中断等等,以前考研时看csapp这本专业书有过详细的理解, 偏理论但实际上没用到过. 关于虚拟地址的空间布局, 引用最前面的程序的执行过程. 虚拟内存的布局: .init .text .rodata; .data .bss; 堆区; 共享内存区; 栈区; 内核区;

### 匿名管道pipe代码示例, 命名管道mkfifo略没必要.
```
int fd[2];
pipe[fd]; // 创建管道, 返回-1表示异常.
pid = fork(); // 创建子进程, 父写子读, 父往fd[1]中write, 子从fd[0]中read.
if (pid > 0) {
    // 父进程:写入数据
    close(fd[0]); // 关闭读端, 读写分别对应01嘛
    char write_msg[] = "hello from parent";
    write(fd[1], write_msg, strlen(write_msg) + 1); // 这+1细节略, 学会抓大放小
    close(fd[1]); // 关闭写端
    wait(NULL); // 等待子进程结束
}
if (pid == 0) {
    // 子进程:读取数据
    close(fd[1]); // 关闭写端
    char read_msg[100];
    read(fd[0], read_msg, sizeof(read_msg));
    close(fd[0]);
}
```
思考: 关于先后顺序以及阻塞问题, 如果管道为空read()会阻塞. 理解到这里就够了. ~~什么管道满了write也会阻塞,这很符合逻辑,但感觉没必要记这个.~~

## 线程锁有哪些?锁的缺点(竞争等待这些), mutex

## lambda表达式/常规函数调用的区别, (functioncal很少很少)

## 设计模式(单例/工厂/观察者). 工厂很复杂,单例饿汉懒汉

## 介绍一些std::move,右值语义,完美转发
视频得再看一下;

## 继承相关(不直接考), 耦合与解耦, 写一个模块如何解耦,耦合问题. 模块化编程

## STL的底层, vector, set, 底层数据结构和内存管理机制. 增容扩张与erase机制.
视频得再看一下;

## malloc new free delete, 数组用的少
new是C++分配内存的主要方式. new返回的是一个指针, 而且我感觉new有比较大的设计缺陷, 就是一个对象和数组对象的返回值是一样的. delete的时候还要做区分.
delete要注意数组情况. 另外智能指针对数组情况的支持不太好, 我记得C++17,C++20对智能指针和数组的支持有了一些提升, 但总体来说数组情况还是得用new和delete, 或者用vector.

malloc/free这是C语音的库函数; 返回的是void*需要手动转化; 失败返回NULL;
new/delete是C++的关键字不完全是函数; 返回的事具体类型的指针; 失败抛出异常; 可以对new进行重载overload;
两者绝对不能混乱, new出来的东西不能free; malloc的东西不能delete; 记忆中还有一个不能混用的, 是智能指针与裸指针不能混用!!!
智能指针可以管理new的内存, 但是推荐使用make_unique和make_shared; 忘记智能指针与new的搭配吧, 容易晕; 最佳实践:`auto ptr = std::make_unique<int>(42);`或`auto str = std::make_unique<string>("hello");`, 把42或hello作为函数参数传递. 
使用new的话我不熟悉: `std::unique_ptr<int> p1(new int(42));`或`auto p2 = std::unique_ptr<int>(new int(42));` `unique_ptr`是模板类(模板类是模板), 带上`<int>`后变成一个类. 等价于`A p1(参数)`或者`auto a = A(参数)`; 分别是直接构造,带参构造函数; 以及拷贝构造函数;
**另外记住：auto 配 =，不配 {}. 因为auto配合初始化有大坑;**

## @ 介绍一下智能指针.
前几天才看过, 略.

## 多继承, 不只是菱形继承, 很复杂, 直接说没用到. chromius不提.
略;

## const int * const ptr;
等价于int const * const ptr; const是修饰左边的东西. 第一个const修饰int,表示指针指向的int值(ptr到ptr+4byte之间的值,通常在栈上或堆中)不可以修改, 又叫做底层const. 第二个const修饰*, 表示指针本身(ptr是一个8byte的值,通常在栈上)不可以修改, 叫做顶层const.
在auto做类型推断的时候, 顶层const可能会被忽略. auto推断中如果加引用或const那么就不会被忽略.
const能用就尽量用, 代码更安全;

## 平时用什么AI工具.
cursor, 谷歌的gemini的deepresearch. 手机上用deepseek. 在华为实习的时候用的内部部署的Qwen-200多B参数的模型较多;
阿里现状: claude code(年轻人)/千问code(老头用,等会就用).




